import * as pulumi from '@pulumi/pulumi'
import * as gcp from '@pulumi/gcp'
import * as k8s from '@pulumi/kubernetes'
import { GitOpsConfig } from './flux'

export type PGOConfig = {
  backupSchedules: {
    full: string
    incremental: string
  }
}

export type PGOResourcesProps = {
  pgoConfig: PGOConfig
  gitOpsConfigs: GitOpsConfig[]
  cluster: gcp.container.Cluster
  projectName: pulumi.Input<string>
  region: pulumi.Input<string>
  k8sProvider: k8s.Provider
}

export function createPGOResources({
  pgoConfig,
  gitOpsConfigs,
  cluster,
  projectName,
  region,
  k8sProvider,
}: PGOResourcesProps) {
  const pgoBackupSA = new gcp.serviceaccount.Account('pgo-backup-sa', {
    accountId: pulumi.interpolate`${cluster.name}-pgo-backup-sa`,
    displayName: 'PGO Backup SA',
  })

  const pgoBackupSARoles = [
    {
      name: 'storage-object-admin',
      role: 'roles/storage.objectAdmin',
    },
  ]

  pgoBackupSARoles.map((x) => {
    new gcp.projects.IAMMember(`pgo-backup-sa-${x.name}-iam-binding`, {
      project: projectName,
      role: x.role,
      member: pulumi.interpolate`serviceAccount:${pgoBackupSA.email}`,
    })
  })

  const pgoBackupBucket = new gcp.storage.Bucket('pgo-backup-bucket', {
    name: pulumi.interpolate`${cluster.name}-db-backup`,
    location: region,
  })

  const pgoNamespace = new k8s.core.v1.Namespace(
    'pgo-namespace',
    {
      metadata: {
        name: 'postgres-operator',
      },
    },
    {
      provider: k8sProvider,
    },
  )

  const pgo = new k8s.kustomize.Directory(
    'pgo',
    {
      directory:
        'https://github.com/CrunchyData/postgres-operator-examples/tree/main/kustomize/install/default',
    },
    { provider: k8sProvider, dependsOn: [pgoNamespace] },
  )

  const users = gitOpsConfigs
    .flatMap((x) =>
      x.repository.targets.map((t) => {
        const name = `${x.name}-${t.name}`
        return {
          name,
          databases: [name],
        }
      }),
    )
    .concat({
      name: 'postgres',
      databases: [],
    })

  const pgoCluster = new k8s.apiextensions.CustomResource(
    'pgo-cluster',
    {
      apiVersion: 'postgres-operator.crunchydata.com/v1beta1',
      kind: 'PostgresCluster',
      metadata: {
        name: 'pgo-cluster',
        namespace: pgoNamespace.metadata.name,
      },
      spec: {
        image:
          'registry.developers.crunchydata.com/crunchydata/crunchy-postgres:ubi8-14.6-0',
        postgresVersion: 14,
        instances: [
          {
            name: 'pgo-instance',
            replicas: 2,
            dataVolumeClaimSpec: {
              accessModes: ['ReadWriteOnce'],
              resources: {
                requests: {
                  storage: '1Gi',
                },
              },
            },
          },
        ],
        metadata: {
          annotations: {
            'iam.gke.io/gcp-service-account': pgoBackupSA.email,
          },
        },
        backups: {
          pgbackrest: {
            image:
              'registry.developers.crunchydata.com/crunchydata/crunchy-pgbackrest:ubi8-2.41-0',
            global: {
              'repo1-path': '/',
              'repo1-gcs-key-type': 'auto',
              'repo1-retention-full': '14',
              'repo1-retention-full-type': 'time',
            },
            repos: [
              {
                name: 'repo1',
                schedules: pgoConfig.backupSchedules,
                gcs: {
                  bucket: pgoBackupBucket.name,
                },
              },
            ],
          },
        },
        users,
      },
    },
    { provider: k8sProvider, dependsOn: [pgoNamespace, pgo] },
  )

  // NOTE:
  // Clone the DB secret generated by PGO to the namespace where applications run
  // This operation will no longer be necessary once the PGO has completed its support.
  // https://github.com/CrunchyData/postgres-operator/issues/2831
  gitOpsConfigs.map((x) => {
    x.repository.targets.map((t) => {
      const name = `${x.name}-${t.name}`
      const dbSecret = k8s.core.v1.Secret.get(
        `pgo-secret-${name}`,
        pulumi.interpolate`${pgoNamespace.metadata.name}/${pgoCluster.metadata.name}-pguser-${name}`,
        {
          provider: k8sProvider,
          dependsOn: [pgoCluster],
        },
      )
      const clonedDbSecret = new k8s.core.v1.Secret(
        `cloned-pgo-secret-${name}`,
        {
          metadata: {
            namespace: name,
            name: dbSecret.metadata.name,
          },
          data: dbSecret.data,
        },
        {
          provider: k8sProvider,
        },
      )
    })
  })

  const pgoKSASuffix = ['instance', 'pgbackrest']

  pgoKSASuffix.map((x) => {
    new gcp.serviceaccount.IAMMember(`pgo-backup-sa-wi-iam-binding-${x}`, {
      serviceAccountId: pgoBackupSA.name,
      role: 'roles/iam.workloadIdentityUser',
      member: pulumi.interpolate`serviceAccount:${projectName}.svc.id.goog[${pgoNamespace.metadata.name}/${pgoCluster.metadata.name}-${x}]`,
    })
  })
}
